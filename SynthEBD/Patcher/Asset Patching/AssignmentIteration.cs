namespace SynthEBD;

/// <summary>
/// Contains the permutation and asssociated data generated by one iteration of the GenerateCombination() function
/// By tracking previously-generated combinations, the patcher avoids entering an infinite loop of re-generating combinations trying to find one that satisfied subgroup and bodygen constraints
/// </summary>
public class AssignmentIteration
{
    public AssignmentIteration()
    {
        PreviouslyGeneratedCombinations = new HashSet<string>();
    }
    public List<FlattenedSubgroup> AvailableSeeds { get; set; } = new();
    public FlattenedSubgroup ChosenSeed { get; set; } = null;
    public FlattenedAssetPack ChosenAssetPack { get; set; } = null;
    public Dictionary<int, FlattenedAssetPack> RemainingVariantsByIndex { get; set; } = new();
    public HashSet<string> PreviouslyGeneratedCombinations = new HashSet<string>();

    public void ChooseSeedSubgroup(IEnumerable<FlattenedSubgroup> availableSeeds)
    {
        // 1. Collect all unique ParentAssetPack members from availableSeeds.
        var uniqueAssetPacks = availableSeeds
            .Select(seed => seed.ParentAssetPack)
            .Distinct();

        // 2. Use the probability selector to pick a parent asset pack based on its probability weighting.
        //    Since FlattenedAssetPack implements IProbabilityWeighted, this works as expected.
        ChosenAssetPack = ProbabilityWeighting.SelectByProbability(uniqueAssetPacks, assetPack => assetPack.DistributionRules.ProbabilityWeighting);
        if (ChosenAssetPack == null)
        {
            return;
        }

        // 3. Filter availableSeeds to those whose ParentAssetPack equals the chosen one.
        var seedsFromChosenPack = availableSeeds
            .Where(seed => seed.ParentAssetPack == ChosenAssetPack);

        // 4. Use the probability selector to randomly select a seed based on seed.ProbabilityWeighting.
        ChosenSeed = (FlattenedSubgroup)ProbabilityWeighting.SelectByProbability(seedsFromChosenPack);
    }
    
    public static int BackTrack(AssignmentIteration iterationInfo, FlattenedSubgroup toRemove, int currentIndex, int steps)
    {
        FlattenedAssetPack revertTo = iterationInfo.RemainingVariantsByIndex[currentIndex - steps];

        if (toRemove != null)
        {
            revertTo.Subgroups[currentIndex - steps].Remove(toRemove);
        }
        iterationInfo.ChosenAssetPack = revertTo;

        return currentIndex - steps - 1; // -1 because the calling for loop will then immediately add 1 back at the next iteration
    }
}